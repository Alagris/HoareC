/*
 * This Java source file was generated by the Gradle 'init' task.
 */
package hoarec;

import java.io.File;
import java.io.IOException;
import java.lang.ProcessBuilder.Redirect;
import java.util.ArrayList;
import java.util.HashSet;
import java.util.LinkedList;

import org.antlr.v4.runtime.CharStream;
import org.antlr.v4.runtime.CharStreams;
import org.antlr.v4.runtime.CommonTokenStream;

import hoarec.GrammarParser.AirthmLastContext;
import hoarec.GrammarParser.AirthmMinusContext;
import hoarec.GrammarParser.AirthmPlusContext;
import hoarec.GrammarParser.ArithmLiteralContext;
import hoarec.GrammarParser.ArithmNegContext;
import hoarec.GrammarParser.ArithmNestedContext;
import hoarec.GrammarParser.ArithmNoNegContext;
import hoarec.GrammarParser.ArithmVarContext;
import hoarec.GrammarParser.AtomArithmContext;
import hoarec.GrammarParser.AtomFalseContext;
import hoarec.GrammarParser.AtomLogicContext;
import hoarec.GrammarParser.AtomTrueContext;
import hoarec.GrammarParser.ConjunctionLastContext;
import hoarec.GrammarParser.ConjunctionMoreContext;
import hoarec.GrammarParser.DisjunctionLastContext;
import hoarec.GrammarParser.DisjunctionMoreContext;
import hoarec.GrammarParser.EquivalenceLastContext;
import hoarec.GrammarParser.EquivalenceMoreContext;
import hoarec.GrammarParser.IDLastContext;
import hoarec.GrammarParser.IDMoreContext;
import hoarec.GrammarParser.ImplicationLastContext;
import hoarec.GrammarParser.ImplicationMoreContext;
import hoarec.GrammarParser.IneqEqContext;
import hoarec.GrammarParser.IneqGeContext;
import hoarec.GrammarParser.IneqGtContext;
import hoarec.GrammarParser.IneqLeContext;
import hoarec.GrammarParser.IneqLtContext;
import hoarec.GrammarParser.IneqNeqContext;
import hoarec.GrammarParser.MultInverseContext;
import hoarec.GrammarParser.MultLastContext;
import hoarec.GrammarParser.MultProductContext;
import hoarec.GrammarParser.NegationFalseContext;
import hoarec.GrammarParser.NegationTrueContext;
import hoarec.GrammarParser.ProcedureContext;
import hoarec.GrammarParser.ProceduresLastContext;
import hoarec.GrammarParser.ProceduresMoreContext;
import hoarec.GrammarParser.StartContext;
import hoarec.GrammarParser.StatementAssignContext;
import hoarec.GrammarParser.StatementClauseContext;
import hoarec.GrammarParser.StatementEchoContext;
import hoarec.GrammarParser.StatementIfContext;
import hoarec.GrammarParser.StatementSkipContext;
import hoarec.GrammarParser.StatementWhileContext;
import hoarec.GrammarParser.StatementsLastContext;
import hoarec.GrammarParser.StatementsMoreContext;

public class Library {
	static void repeat(StringBuilder sb, String s, int times) {
		while (times-- > 0) {
			sb.append(s);
		}
	}

	static void ind(StringBuilder sb, int indent) {
		repeat(sb, "    ", indent);
	}

	interface GoalOrHole {
		void toAltErgo(StringBuilder sb);
	}

	enum HoleCause {
		MISSING_ANNOTATION, SUPERFLUOUS_ANNOTATION
	}

	static class Hole implements GoalOrHole {
		int line;
		HoleCause cause;

		public Hole(int line, HoleCause cause) {
			this.line = line;
			this.cause = cause;
		}

		@Override
		public void toAltErgo(StringBuilder sb) {
			switch (cause) {
			case MISSING_ANNOTATION:
				sb.append("Missing annotation at line ").append(line);
				break;
			case SUPERFLUOUS_ANNOTATION:
				sb.append("Superfluous annotation at line ").append(line);
				break;
			}
		}
	}

	interface SingleGoal extends GoalOrHole {
		AE goal();

		int line();

		@Override
		default void toAltErgo(StringBuilder sb) {
			sb.append("at line ").append(line()).append(":\n");
			goal().serialize(sb);
		}
	}

	static class GoalSkip implements SingleGoal {
		AE goal;
		int line;

		public GoalSkip(Op precondition, int line, Op postcondition) {
			this.line = line;
			goal = new OpImpl(precondition, postcondition).toAltErgo();
		}

		@Override
		public AE goal() {
			return goal;
		}

		@Override
		public int line() {
			return line;
		}
	}

	static class GoalAssign implements SingleGoal {
		final AE goal;
		final int line;

		public GoalAssign(Op precondition, Assignment ass, Op postcondition) {
			Op weakestPrecondition = postcondition.substitute(ass.name, ass.value);
			goal = new OpImpl(precondition, weakestPrecondition).toAltErgo();
			line = ass.line;
		}

		@Override
		public AE goal() {
			return goal;
		}

		@Override
		public int line() {
			return line;
		}
	}

	interface ProcedureAST extends AST {

		void toC(int indent, StringBuilder sb, HashSet<String> ghosts);

	}

	interface AST {

	}

	static class Procedures implements AST {
		LinkedList<Procedure> procedures = new LinkedList<>();

		public void serialize(int indent, StringBuilder sb) {
			for (Procedure procedure : procedures) {
				procedure.serialize(indent, sb);
			}
		}

		public void toC(StringBuilder sb) {
			sb.append("#include<stdio.h>\n");
			for (Procedure procedure : procedures) {
				procedure.toC(sb);
			}
		}

		public String toC() {
			StringBuilder sb = new StringBuilder();
			toC(sb);
			return sb.toString();
		}

		public LinkedList<GoalOrHole> hoareGoals() {
			LinkedList<GoalOrHole> goals = new LinkedList<>();
			for (Procedure procedure : procedures) {
				procedure.hoareGoals(goals);
			}
			return goals;
		}

		public String str() {
			StringBuilder sb = new StringBuilder();
			serialize(0, sb);
			return sb.toString();
		}
	}

	public static final String C_INT = "long long int";

	static class Procedure implements AST {
		HashSet<String> variables, ghosts;
		Op requires, ensures;
		Statements steps;
		String name;
		int line;

		public Procedure(int line) {
			this.line = line;
		}

		public void serialize(int indent, StringBuilder sb) {
			ind(sb, indent);
			sb.append("procedure ").append(name).append("\n");
			ind(sb, indent + 1);
			sb.append("requires ");
			requires.serialize(sb);
			sb.append('\n');
			ind(sb, indent + 1);
			sb.append("ensures ");
			ensures.serialize(sb);
			sb.append('\n');
			ind(sb, indent + 1);
			sb.append("variables");
			for (String var : variables) {
				sb.append(" ").append(var);
			}
			sb.append("\n");
			ind(sb, indent + 1);
			sb.append("ghosts");
			for (String ghost : ghosts) {
				sb.append(" ").append(ghost);
			}
			sb.append("\n");
			ind(sb, indent + 1);
			sb.append("steps\n");
			steps.serialize(indent + 1, sb);
			ind(sb, indent);
			sb.append("end\n");

		}

		public void toC(StringBuilder sb) {
			HashSet<String> vars = new HashSet<>(variables);
			steps.collectVariables(vars, ghosts);
			sb.append(("main".equals(name) ? "int " : "void ") + name + "(){\n");
			for (String var : vars) {
				ind(sb, 1);
				sb.append(C_INT).append(' ').append(var).append(";\n");
			}
			steps.toC(1, sb, ghosts);
			sb.append("}\n");

		}

		public void hoareGoals(LinkedList<GoalOrHole> goals) {
			steps.hoareGoals(goals, line, requires, ensures);
		}

	}

	/** AltErgo AST */
	interface AE {
		String opString();

		int precedence();

		void serialize(StringBuilder sb);
	}

	interface AEBinary extends AE {
		AE lhs();

		AE rhs();

		default void serialize(StringBuilder sb) {
			if (lhs().precedence() >= precedence()) {
				sb.append("(");
				lhs().serialize(sb);
				sb.append(")");
			} else {
				lhs().serialize(sb);
			}
			sb.append(' ').append(opString()).append(' ');
			if (rhs().precedence() > precedence()) {
				sb.append("(");
				rhs().serialize(sb);
				sb.append(")");
			} else {
				rhs().serialize(sb);
			}
		}

	}

	interface AEUnary extends AE {
		AE op();

		default void serialize(StringBuilder sb) {
			if (op().precedence() > precedence()) {
				sb.append(opString());
				sb.append("(");
				op().serialize(sb);
				sb.append(")");
			} else {
				sb.append(opString()).append(' ');
				op().serialize(sb);
			}
		}

	}

	static class AEEquiv implements AEBinary {
		AE lhs, rhs;

		public AEEquiv(AE lhs, AE rhs) {
			this.lhs = lhs;
			this.rhs = rhs;
		}

		@Override
		public int precedence() {
			return 5;
		}

		@Override
		public String opString() {
			return "<->";
		}

		@Override
		public AE lhs() {
			return lhs;
		}

		@Override
		public AE rhs() {
			return rhs;
		}
	}

	static class AEImpl implements AEBinary {
		AE lhs, rhs;

		public AEImpl(AE lhs, AE rhs) {
			this.lhs = lhs;
			this.rhs = rhs;
		}

		@Override
		public String opString() {
			return "->";
		}

		@Override
		public AE lhs() {
			return lhs;
		}

		@Override
		public AE rhs() {
			return rhs;
		}

		@Override
		public int precedence() {
			return 4;
		}

	}

	static class AEAnd implements AEBinary {
		AE lhs, rhs;

		public AEAnd(AE lhs, AE rhs) {
			this.lhs = lhs;
			this.rhs = rhs;
		}

		@Override
		public String opString() {
			return "and";
		}

		@Override
		public AE lhs() {
			return lhs;
		}

		@Override
		public AE rhs() {
			return rhs;
		}

		@Override
		public int precedence() {
			return 2;
		}
	}

	static class AEOr implements AEBinary {
		AE lhs, rhs;

		public AEOr(AE lhs, AE rhs) {
			this.lhs = lhs;
			this.rhs = rhs;
		}

		@Override
		public String opString() {
			return "or";
		}

		@Override
		public AE lhs() {
			return lhs;
		}

		@Override
		public AE rhs() {
			return rhs;
		}

		@Override
		public int precedence() {
			return 3;
		}
	}

	static class AENot implements AEUnary {
		AE op;

		public AENot(AE op) {
			this.op = op;
		}

		@Override
		public String opString() {
			return "not";
		}

		@Override
		public AE op() {
			return op;
		}

		@Override
		public int precedence() {
			return 1;
		}
	}

	static class AEEq implements AE {
		final AEArith lhs, rhs;

		public AEEq(final AEArith lhs, final AEArith rhs) {
			this.lhs = lhs;
			this.rhs = rhs;
		}

		@Override
		public String opString() {
			return "=";
		}

		@Override
		public int precedence() {
			return 0;
		}

		@Override
		public void serialize(StringBuilder sb) {
			sb.append('(');
			lhs.serialize(sb);
			sb.append(' ').append(opString()).append(' ');
			rhs.serialize(sb);
			sb.append(')');
		}

	}

	static class AELt implements AE {
		final AEArith lhs, rhs;

		public AELt(final AEArith lhs, final AEArith rhs) {
			this.lhs = lhs;
			this.rhs = rhs;
		}

		@Override
		public String opString() {
			return "<";
		}

		@Override
		public int precedence() {
			return 0;
		}

		@Override
		public void serialize(StringBuilder sb) {
			sb.append('(');
			lhs.serialize(sb);
			sb.append(' ').append(opString()).append(' ');
			rhs.serialize(sb);
			sb.append(')');
		}

	}

	static class AELe implements AE {
		final AEArith lhs, rhs;

		public AELe(final AEArith lhs, final AEArith rhs) {
			this.lhs = lhs;
			this.rhs = rhs;
		}

		@Override
		public String opString() {
			return "<=";
		}

		@Override
		public int precedence() {
			return 0;
		}

		@Override
		public void serialize(StringBuilder sb) {
			sb.append('(');
			lhs.serialize(sb);
			sb.append(' ').append(opString()).append(' ');
			rhs.serialize(sb);
			sb.append(')');
		}

	}

	static class AETrue implements AE {

		@Override
		public String opString() {
			return "true";
		}

		@Override
		public int precedence() {
			return 0;
		}

		@Override
		public void serialize(StringBuilder sb) {
			sb.append(opString());
		}
	}

	static class AEFalse implements AE {

		@Override
		public String opString() {
			return "false";
		}

		@Override
		public int precedence() {
			return 0;
		}

		@Override
		public void serialize(StringBuilder sb) {
			sb.append(opString());
		}

	}

	public static final AE AE_TRUE = new AETrue();
	public static final AE AE_FALSE = new AEFalse();

	interface AEArith {

		void serialize(StringBuilder sb);

		int precedence();

		String opString();

	}

	interface AEArithBinary extends AEArith {
		AEArith lhs();

		AEArith rhs();

		default void serialize(StringBuilder sb) {
			if (lhs().precedence() > precedence()) {
				sb.append("(");
				lhs().serialize(sb);
				sb.append(")");
			} else {
				lhs().serialize(sb);
			}
			sb.append(' ').append(opString()).append(' ');
			if (rhs().precedence() >= precedence()) {
				sb.append("(");
				rhs().serialize(sb);
				sb.append(")");
			} else {
				rhs().serialize(sb);
			}
		}

	}

	interface AEArithUnary extends AEArith {
		AEArith op();

		default void serialize(StringBuilder sb) {
			if (op().precedence() > precedence()) {
				sb.append(opString());
				sb.append("(");
				op().serialize(sb);
				sb.append(")");
			} else {
				sb.append(opString());
				op().serialize(sb);
			}

		}

	}

	// Operator precedence:
	// - 1
	// * / 2
	// + - 3
	static class AEPlus implements AEArithBinary {
		final AEArith lhs, rhs;

		public AEPlus(final AEArith lhs, final AEArith rhs) {
			this.lhs = lhs;
			this.rhs = rhs;
		}

		@Override
		public int precedence() {
			return 3;
		}

		@Override
		public String opString() {
			return "+";
		}

		@Override
		public final AEArith lhs() {
			return lhs;
		}

		@Override
		public final AEArith rhs() {
			return rhs;
		}

	}

	static class AESub implements AEArithBinary {
		final AEArith lhs, rhs;

		public AESub(final AEArith lhs, final AEArith rhs) {
			this.lhs = lhs;
			this.rhs = rhs;
		}

		@Override
		public int precedence() {
			return 3;
		}

		@Override
		public String opString() {
			return "-";
		}

		@Override
		public final AEArith lhs() {
			return lhs;
		}

		@Override
		public final AEArith rhs() {
			return rhs;
		}
	}

	static class AENeg implements AEArithUnary {
		final AEArith op;

		public AENeg(final AEArith op) {
			this.op = op;
		}

		@Override
		public int precedence() {
			return 1;
		}

		@Override
		public String opString() {
			return "-";
		}

		@Override
		public AEArith op() {
			return op;
		}
	}

	static class AEMul implements AEArithBinary {
		final AEArith lhs, rhs;

		public AEMul(final AEArith lhs, final AEArith rhs) {
			this.lhs = lhs;
			this.rhs = rhs;
		}

		@Override
		public int precedence() {
			return 2;
		}

		@Override
		public String opString() {
			return "*";
		}

		@Override
		public final AEArith lhs() {
			return lhs;
		}

		@Override
		public final AEArith rhs() {
			return rhs;
		}
	}

	static class AEDiv implements AEArithBinary {
		final AEArith lhs, rhs;

		public AEDiv(final AEArith lhs, final AEArith rhs) {
			this.lhs = lhs;
			this.rhs = rhs;
		}

		@Override
		public int precedence() {
			return 3;
		}

		@Override
		public String opString() {
			return "/";
		}

		@Override
		public final AEArith lhs() {
			return lhs;
		}

		@Override
		public final AEArith rhs() {
			return rhs;
		}
	}

	static class AEInt implements AEArith {
		final int literal;

		public AEInt(int literal) {
			this.literal = literal;
		}

		@Override
		public void serialize(StringBuilder sb) {
			sb.append(literal);
		}

		@Override
		public int precedence() {
			return 0;
		}

		@Override
		public String opString() {
			return String.valueOf(literal);
		}

	}

	static class AEVar implements AEArith {
		final String var;

		public AEVar(String var) {
			this.var = var;
		}

		@Override
		public void serialize(StringBuilder sb) {
			sb.append(var);
		}

		@Override
		public int precedence() {
			return 0;
		}

		@Override
		public String opString() {
			return var;
		}

	}

	interface C {
		int precedence();

		void serialize(StringBuilder sb);
	}

	interface CBinary extends C {
		C lhs();

		C rhs();

		String opString();

		default boolean leftToRightAssociative() {
			return true;
		}

		default void serialize(StringBuilder sb) {
			if (leftToRightAssociative()) {
				if (lhs().precedence() >= precedence()) {
					sb.append("(");
					lhs().serialize(sb);
					sb.append(")");
				} else {
					lhs().serialize(sb);
				}
				sb.append(' ').append(opString()).append(' ');
				if (rhs().precedence() > precedence()) {
					sb.append("(");
					rhs().serialize(sb);
					sb.append(")");
				} else {
					rhs().serialize(sb);
				}
			} else {
				if (lhs().precedence() > precedence()) {
					sb.append("(");
					lhs().serialize(sb);
					sb.append(")");
				} else {
					lhs().serialize(sb);
				}
				sb.append(' ').append(opString()).append(' ');
				if (rhs().precedence() >= precedence()) {
					sb.append("(");
					rhs().serialize(sb);
					sb.append(")");
				} else {
					rhs().serialize(sb);
				}
			}
		}

	}

	interface CUnary extends C {
		C op();

		String opString();

		default boolean leftToRightAssociative() {
			return true;
		}

		default void serialize(StringBuilder sb) {

			sb.append(opString());
			if (op().precedence() > precedence()) {
				sb.append("(");
				op().serialize(sb);
				sb.append(")");
			} else {
				op().serialize(sb);
			}

		}

	}

	static class CXor implements CBinary {
		C lhs, rhs;

		public CXor(C lhs, C rhs) {
			this.lhs = lhs;
			this.rhs = rhs;
		}

		@Override
		public C lhs() {
			return lhs;
		}

		@Override
		public C rhs() {
			return rhs;
		}

		@Override
		public String opString() {
			return "^";
		}

		@Override
		public int precedence() {
			return 9;
		}
	}

	static class CAnd implements CBinary {
		C lhs, rhs;

		public CAnd(C lhs, C rhs) {
			this.lhs = lhs;
			this.rhs = rhs;
		}

		@Override
		public C lhs() {
			return lhs;
		}

		@Override
		public C rhs() {
			return rhs;
		}

		@Override
		public String opString() {
			return "&&";
		}

		@Override
		public int precedence() {
			return 11;
		}
	}

	static class COr implements CBinary {
		C lhs, rhs;

		public COr(C lhs, C rhs) {
			this.lhs = lhs;
			this.rhs = rhs;
		}

		@Override
		public C lhs() {
			return lhs;
		}

		@Override
		public C rhs() {
			return rhs;
		}

		@Override
		public String opString() {
			return "||";
		}

		@Override
		public int precedence() {
			return 12;
		}
	}

	static class CEq implements CBinary {
		C lhs, rhs;

		public CEq(C lhs, C rhs) {
			this.lhs = lhs;
			this.rhs = rhs;
		}

		@Override
		public C lhs() {
			return lhs;
		}

		@Override
		public C rhs() {
			return rhs;
		}

		@Override
		public String opString() {
			return "==";
		}

		@Override
		public int precedence() {
			return 7;
		}
	}

	static class CNEq implements CBinary {
		C lhs, rhs;

		public CNEq(C lhs, C rhs) {
			this.lhs = lhs;
			this.rhs = rhs;
		}

		@Override
		public C lhs() {
			return lhs;
		}

		@Override
		public C rhs() {
			return rhs;
		}

		@Override
		public String opString() {
			return "!=";
		}

		@Override
		public int precedence() {
			return 7;
		}
	}

	static class CLt implements CBinary {
		C lhs, rhs;

		public CLt(C lhs, C rhs) {
			this.lhs = lhs;
			this.rhs = rhs;
		}

		@Override
		public C lhs() {
			return lhs;
		}

		@Override
		public C rhs() {
			return rhs;
		}

		@Override
		public String opString() {
			return "<";
		}

		@Override
		public int precedence() {
			return 6;
		}
	}

	static class CLe implements CBinary {
		C lhs, rhs;

		public CLe(C lhs, C rhs) {
			this.lhs = lhs;
			this.rhs = rhs;
		}

		@Override
		public C lhs() {
			return lhs;
		}

		@Override
		public C rhs() {
			return rhs;
		}

		@Override
		public String opString() {
			return "<=";
		}

		@Override
		public int precedence() {
			return 6;
		}
	}

	static class CNot implements CUnary {
		C op;

		public CNot(C op) {
			this.op = op;
		}

		@Override
		public C op() {
			return op;
		}

		@Override
		public String opString() {
			return "!";
		}

		@Override
		public int precedence() {
			return 2;
		}
	}

	static class CMul implements CBinary {
		C lhs, rhs;

		public CMul(C lhs, C rhs) {
			this.lhs = lhs;
			this.rhs = rhs;
		}

		@Override
		public C lhs() {
			return lhs;
		}

		@Override
		public C rhs() {
			return rhs;
		}

		@Override
		public String opString() {
			return "*";
		}

		@Override
		public int precedence() {
			return 3;
		}
	}

	static class CPlus implements CBinary {
		C lhs, rhs;

		public CPlus(C lhs, C rhs) {
			this.lhs = lhs;
			this.rhs = rhs;
		}

		@Override
		public C lhs() {
			return lhs;
		}

		@Override
		public C rhs() {
			return rhs;
		}

		@Override
		public String opString() {
			return "+";
		}

		@Override
		public int precedence() {
			return 4;
		}
	}

	static class CSub implements CBinary {
		C lhs, rhs;

		public CSub(C lhs, C rhs) {
			this.lhs = lhs;
			this.rhs = rhs;
		}

		@Override
		public C lhs() {
			return lhs;
		}

		@Override
		public C rhs() {
			return rhs;
		}

		@Override
		public String opString() {
			return "-";
		}

		@Override
		public int precedence() {
			return 4;
		}
	}

	static class CDiv implements CBinary {
		C lhs, rhs;

		public CDiv(C lhs, C rhs) {
			this.lhs = lhs;
			this.rhs = rhs;
		}

		@Override
		public C lhs() {
			return lhs;
		}

		@Override
		public C rhs() {
			return rhs;
		}

		@Override
		public String opString() {
			return "/";
		}

		@Override
		public int precedence() {
			return 3;
		}
	}

	static class CVar implements C {
		final String var;

		public CVar(String var) {
			this.var = var;
		}

		@Override
		public int precedence() {
			return 0;
		}

		@Override
		public void serialize(StringBuilder sb) {
			sb.append(var);
		}

	}

	static class CInt implements C {
		final int var;

		public CInt(int var) {
			this.var = var;
		}

		@Override
		public int precedence() {
			return 0;
		}

		@Override
		public void serialize(StringBuilder sb) {
			sb.append(var);
		}

	}

	public static final CInt C_ZERO = new CInt(0), C_ONE = new CInt(1);

	static class CNeg implements CUnary {
		final C op;

		public CNeg(C op) {
			this.op = op;
		}

		@Override
		public String opString() {
			return "-";
		}

		@Override
		public C op() {
			return op;
		}

		@Override
		public int precedence() {
			return 2;
		}

	}

	interface Op extends AST {

		Op substitute(String name, final Arith op);

		String opString();

		int precedence();

		void serialize(StringBuilder sb);

		void validateVariables(HashSet<String> vars, HashSet<String> ghosts, boolean allowUseOfGhosts);

		C toC();

		AE toAltErgo();
	}

	interface OpBinary extends Op {
		Op lhs();

		Op rhs();

		default void serialize(StringBuilder sb) {
			if (lhs().precedence() >= precedence()) {
				sb.append("(");
				lhs().serialize(sb);
				sb.append(")");
			} else {
				lhs().serialize(sb);
			}
			sb.append(' ').append(opString()).append(' ');
			if (rhs().precedence() > precedence()) {
				sb.append("(");
				rhs().serialize(sb);
				sb.append(")");
			} else {
				rhs().serialize(sb);
			}
		}

		default public void validateVariables(HashSet<String> vars, HashSet<String> ghosts, boolean allowUseOfGhosts) {
			lhs().validateVariables(vars, ghosts, allowUseOfGhosts);
			rhs().validateVariables(vars, ghosts, allowUseOfGhosts);
		}
	}

	interface OpUnary extends Op {
		Op op();

		default void serialize(StringBuilder sb) {
			if (op().precedence() > precedence()) {
				sb.append(opString());
				sb.append("(");
				op().serialize(sb);
				sb.append(")");
			} else {
				sb.append(opString());
				op().serialize(sb);
			}
		}

		default public void validateVariables(HashSet<String> vars, HashSet<String> ghosts, boolean allowUseOfGhosts) {
			op().validateVariables(vars, ghosts, allowUseOfGhosts);
		}
	}

	// Operator precedence:
	// ~ 1
	// /\ 2
	// \/ 3
	// -> 4
	// <-> 5

	static class OpEquiv implements OpBinary {
		final Op lhs, rhs;

		public OpEquiv(final Op lhs, Op rhs) {
			this.lhs = lhs;
			this.rhs = rhs;
		}

		@Override
		public C toC() {
			return new CEq(lhs.toC(), rhs.toC());
		}

		@Override
		public Op substitute(String name, final Arith op) {
			return new OpEquiv(lhs.substitute(name, op), rhs.substitute(name, op));
		}

		@Override
		public int precedence() {
			return 5;
		}

		@Override
		public String opString() {
			return "<=>";
		}

		@Override
		public Op lhs() {
			return lhs;
		}

		@Override
		public Op rhs() {
			return rhs;
		}

		@Override
		public AE toAltErgo() {
			return new AEEquiv(lhs.toAltErgo(), rhs.toAltErgo());
		}
	}

	static class OpImpl implements OpBinary {
		final Op lhs, rhs;

		@Override
		public AE toAltErgo() {
			return new AEImpl(lhs.toAltErgo(), rhs.toAltErgo());
		}

		@Override
		public C toC() {
			return new COr(new CNot(lhs.toC()), rhs.toC());
		}

		public OpImpl(final Op lhs, Op rhs) {
			this.lhs = lhs;
			this.rhs = rhs;
		}

		@Override
		public Op substitute(String name, final Arith op) {
			return new OpImpl(lhs.substitute(name, op), rhs.substitute(name, op));
		}

		@Override
		public String opString() {
			return "=>";
		}

		@Override
		public Op lhs() {
			return lhs;
		}

		@Override
		public Op rhs() {
			return rhs;
		}

		@Override
		public int precedence() {
			return 4;
		}

	}

	static class OpAnd implements OpBinary {
		final Op lhs, rhs;

		@Override
		public AE toAltErgo() {
			return new AEAnd(lhs.toAltErgo(), rhs.toAltErgo());
		}

		public OpAnd(final Op lhs, Op rhs) {
			this.lhs = lhs;
			this.rhs = rhs;
		}

		@Override
		public C toC() {
			return new CAnd(lhs.toC(), rhs.toC());
		}

		@Override
		public Op substitute(String name, final Arith op) {
			return new OpAnd(lhs.substitute(name, op), rhs.substitute(name, op));
		}

		@Override
		public String opString() {
			return "/\\";
		}

		@Override
		public Op lhs() {
			return lhs;
		}

		@Override
		public Op rhs() {
			return rhs;
		}

		@Override
		public int precedence() {
			return 2;
		}
	}

	static class OpOr implements OpBinary {
		final Op lhs, rhs;

		@Override
		public AE toAltErgo() {
			return new AEOr(lhs.toAltErgo(), rhs.toAltErgo());
		}

		@Override
		public C toC() {
			return new COr(lhs.toC(), rhs.toC());
		}

		public OpOr(final Op lhs, Op rhs) {
			this.lhs = lhs;
			this.rhs = rhs;
		}

		@Override
		public Op substitute(String name, final Arith op) {
			return new OpOr(lhs.substitute(name, op), rhs.substitute(name, op));
		}

		@Override
		public String opString() {
			return "\\/";
		}

		@Override
		public Op lhs() {
			return lhs;
		}

		@Override
		public Op rhs() {
			return rhs;
		}

		@Override
		public int precedence() {
			return 3;
		}
	}

	static class OpNot implements OpUnary {
		Op op;

		@Override
		public AE toAltErgo() {
			return new AENot(op.toAltErgo());
		}

		@Override
		public C toC() {
			return new CNot(op.toC());
		}

		public OpNot(Op op) {
			this.op = op;
		}

		@Override
		public Op substitute(String name, final Arith op) {
			return new OpNot(this.op.substitute(name, op));
		}

		@Override
		public String opString() {
			return "~";
		}

		@Override
		public Op op() {
			return op;
		}

		@Override
		public int precedence() {
			return 1;
		}
	}

	static class OpEq implements Op {
		final Arith lhs, rhs;

		@Override
		public AE toAltErgo() {
			return new AEEq(lhs.toAltErgo(), rhs.toAltErgo());
		}

		@Override
		public C toC() {
			return new CEq(lhs.toC(), rhs.toC());
		}

		public OpEq(final Arith lhs, final Arith rhs) {
			this.lhs = lhs;
			this.rhs = rhs;
		}

		@Override
		public Op substitute(String name, final Arith op) {
			return new OpEq(lhs.substitute(name, op), rhs.substitute(name, op));
		}

		@Override
		public String opString() {
			return "=";
		}

		@Override
		public int precedence() {
			return 0;
		}

		@Override
		public void serialize(StringBuilder sb) {
			lhs.serialize(sb);
			sb.append(' ').append(opString()).append(' ');
			rhs.serialize(sb);
		}

		@Override
		public void validateVariables(HashSet<String> vars, HashSet<String> ghosts, boolean allowUseOfGhosts) {
			lhs.validateVariables(vars, ghosts, allowUseOfGhosts);
			rhs.validateVariables(vars, ghosts, allowUseOfGhosts);
		}
	}

	static class OpLt implements Op {
		final Arith lhs, rhs;

		@Override
		public AE toAltErgo() {
			return new AELt(lhs.toAltErgo(), rhs.toAltErgo());
		}

		@Override
		public C toC() {
			return new CLt(lhs.toC(), rhs.toC());
		}

		public OpLt(final Arith lhs, final Arith rhs) {
			this.lhs = lhs;
			this.rhs = rhs;
		}

		@Override
		public Op substitute(String name, final Arith op) {
			return new OpLt(lhs.substitute(name, op), rhs.substitute(name, op));
		}

		@Override
		public String opString() {
			return "<";
		}

		@Override
		public int precedence() {
			return 0;
		}

		@Override
		public void serialize(StringBuilder sb) {
			lhs.serialize(sb);
			sb.append(' ').append(opString()).append(' ');
			rhs.serialize(sb);
		}

		@Override
		public void validateVariables(HashSet<String> vars, HashSet<String> ghosts, boolean allowUseOfGhosts) {
			lhs.validateVariables(vars, ghosts, allowUseOfGhosts);
			rhs.validateVariables(vars, ghosts, allowUseOfGhosts);
		}
	}

	static class OpLe implements Op {
		final Arith lhs, rhs;

		@Override
		public AE toAltErgo() {
			return new AELe(lhs.toAltErgo(), rhs.toAltErgo());
		}

		@Override
		public C toC() {
			return new CLe(lhs.toC(), rhs.toC());
		}

		public OpLe(final Arith lhs, final Arith rhs) {
			this.lhs = lhs;
			this.rhs = rhs;
		}

		@Override
		public Op substitute(String name, final Arith op) {
			return new OpLe(lhs.substitute(name, op), rhs.substitute(name, op));
		}

		@Override
		public String opString() {
			return "<=";
		}

		@Override
		public int precedence() {
			return 0;
		}

		@Override
		public void serialize(StringBuilder sb) {
			lhs.serialize(sb);
			sb.append(' ').append(opString()).append(' ');
			rhs.serialize(sb);
		}

		@Override
		public void validateVariables(HashSet<String> vars, HashSet<String> ghosts, boolean allowUseOfGhosts) {
			lhs.validateVariables(vars, ghosts, allowUseOfGhosts);
			rhs.validateVariables(vars, ghosts, allowUseOfGhosts);
		}
	}

	static class OpTrue implements Op {
		@Override
		public AE toAltErgo() {
			return AE_TRUE;
		}

		@Override
		public C toC() {
			return C_ONE;
		}

		@Override
		public Op substitute(String name, final Arith op) {
			return this;
		}

		@Override
		public String opString() {
			return "true";
		}

		@Override
		public int precedence() {
			return 0;
		}

		@Override
		public void serialize(StringBuilder sb) {
			sb.append(opString());
		}

		@Override
		public void validateVariables(HashSet<String> vars, HashSet<String> ghosts, boolean allowUseOfGhosts) {

		}
	}

	static class OpFalse implements Op {
		@Override
		public AE toAltErgo() {
			return AE_FALSE;
		}

		@Override
		public C toC() {
			return C_ZERO;
		}

		@Override
		public Op substitute(String name, final Arith op) {
			return this;
		}

		@Override
		public String opString() {
			return "false";
		}

		@Override
		public int precedence() {
			return 0;
		}

		@Override
		public void serialize(StringBuilder sb) {
			sb.append(opString());
		}

		@Override
		public void validateVariables(HashSet<String> vars, HashSet<String> ghosts, boolean allowUseOfGhosts) {
		}
	}

	public static final Op TRUE = new OpTrue();
	public static final Op FALSE = new OpFalse();

	interface Arith extends AST {
		public Arith substitute(String name, final Arith op);

		public Arith copy();

		void serialize(StringBuilder sb);

		int precedence();

		String opString();

		void validateVariables(HashSet<String> vars, HashSet<String> ghosts, boolean allowUseOfGhosts);

		public C toC();

		public AEArith toAltErgo();
	}

	interface ArithBinary extends Arith {
		Arith lhs();

		Arith rhs();

		default void serialize(StringBuilder sb) {
			if (lhs().precedence() > precedence()) {
				sb.append("(");
				lhs().serialize(sb);
				sb.append(")");
			} else {
				lhs().serialize(sb);
			}
			sb.append(' ').append(opString()).append(' ');
			if (rhs().precedence() >= precedence()) {
				sb.append("(");
				rhs().serialize(sb);
				sb.append(")");
			} else {
				rhs().serialize(sb);
			}
		}

		default public void validateVariables(HashSet<String> vars, HashSet<String> ghosts, boolean allowUseOfGhosts) {
			lhs().validateVariables(vars, ghosts, allowUseOfGhosts);
			rhs().validateVariables(vars, ghosts, allowUseOfGhosts);
		}
	}

	interface ArithUnary extends Arith {
		Arith op();

		default void serialize(StringBuilder sb) {
			if (op().precedence() > precedence()) {
				sb.append(opString());
				sb.append("(");
				op().serialize(sb);
				sb.append(")");
			} else {
				sb.append(opString());
				op().serialize(sb);
			}

		}

		default public void validateVariables(HashSet<String> vars, HashSet<String> ghosts, boolean allowUseOfGhosts) {
			op().validateVariables(vars, ghosts, allowUseOfGhosts);
		}

	}

	// Operator precedence:
	// - 1
	// * / 2
	// + - 3
	static class OpPlus implements ArithBinary {
		final Arith lhs, rhs;

		@Override
		public AEArith toAltErgo() {
			return new AEPlus(lhs.toAltErgo(), rhs.toAltErgo());
		}

		@Override
		public C toC() {
			return new CPlus(lhs.toC(), rhs.toC());
		}

		public OpPlus(final Arith lhs, final Arith rhs) {
			this.lhs = lhs;
			this.rhs = rhs;
		}

		@Override
		public Arith substitute(String name, final Arith op) {
			return new OpPlus(lhs.substitute(name, op), rhs.substitute(name, op));
		}

		@Override
		public Arith copy() {
			return new OpPlus(lhs.copy(), rhs.copy());
		}

		@Override
		public int precedence() {
			return 3;
		}

		@Override
		public String opString() {
			return "+";
		}

		@Override
		public Arith lhs() {
			return lhs;
		}

		@Override
		public Arith rhs() {
			return rhs;
		}

	}

	static class OpSub implements ArithBinary {
		final Arith lhs, rhs;

		@Override
		public AEArith toAltErgo() {
			return new AESub(lhs.toAltErgo(), rhs.toAltErgo());
		}

		@Override
		public C toC() {
			return new CSub(lhs.toC(), rhs.toC());
		}

		public OpSub(final Arith lhs, final Arith rhs) {
			this.lhs = lhs;
			this.rhs = rhs;
		}

		@Override
		public Arith copy() {
			return new OpSub(lhs.copy(), rhs.copy());
		}

		@Override
		public Arith substitute(String name, final Arith op) {
			return new OpSub(lhs.substitute(name, op), rhs.substitute(name, op));
		}

		@Override
		public int precedence() {
			return 3;
		}

		@Override
		public String opString() {
			return "-";
		}

		@Override
		public Arith lhs() {
			return lhs;
		}

		@Override
		public Arith rhs() {
			return rhs;
		}
	}

	static class OpNeg implements ArithUnary {
		final Arith op;

		@Override
		public AEArith toAltErgo() {
			return new AENeg(op.toAltErgo());
		}

		@Override
		public C toC() {
			return new CNeg(op.toC());
		}

		public OpNeg(final Arith op) {
			this.op = op;
		}

		@Override
		public Arith copy() {
			return new OpNeg(op.copy());
		}

		@Override
		public Arith substitute(String name, final Arith op) {
			return new OpNeg(this.op.substitute(name, op));
		}

		@Override
		public int precedence() {
			return 1;
		}

		@Override
		public String opString() {
			return "-";
		}

		@Override
		public Arith op() {
			return op;
		}
	}

	static class OpMul implements ArithBinary {
		final Arith lhs, rhs;

		@Override
		public AEArith toAltErgo() {
			return new AEMul(lhs.toAltErgo(), rhs.toAltErgo());
		}

		@Override
		public C toC() {
			return new CMul(lhs.toC(), rhs.toC());
		}

		public OpMul(final Arith lhs, final Arith rhs) {
			this.lhs = lhs;
			this.rhs = rhs;
		}

		@Override
		public Arith copy() {
			return new OpMul(lhs.copy(), rhs.copy());
		}

		@Override
		public Arith substitute(String name, final Arith op) {
			return new OpMul(lhs.substitute(name, op), rhs.substitute(name, op));
		}

		@Override
		public int precedence() {
			return 2;
		}

		@Override
		public String opString() {
			return "*";
		}

		@Override
		public Arith lhs() {
			return lhs;
		}

		@Override
		public Arith rhs() {
			return rhs;
		}
	}

	static class OpDiv implements ArithBinary {
		final Arith lhs, rhs;

		@Override
		public AEArith toAltErgo() {
			return new AEDiv(lhs.toAltErgo(), rhs.toAltErgo());
		}

		@Override
		public C toC() {
			return new CDiv(lhs.toC(), rhs.toC());
		}

		@Override
		public Arith copy() {
			return new OpDiv(lhs.copy(), rhs.copy());
		}

		public OpDiv(final Arith lhs, final Arith rhs) {
			this.lhs = lhs;
			this.rhs = rhs;
		}

		@Override
		public Arith substitute(String name, final Arith op) {
			return new OpDiv(lhs.substitute(name, op), rhs.substitute(name, op));
		}

		@Override
		public int precedence() {
			return 3;
		}

		@Override
		public String opString() {
			return "/";
		}

		@Override
		public Arith lhs() {
			return lhs;
		}

		@Override
		public Arith rhs() {
			return rhs;
		}
	}

	static class OpInt implements Arith {
		final int literal;

		final int line;

		@Override
		public AEArith toAltErgo() {
			return new AEInt(literal);
		}

		@Override
		public C toC() {
			return new CInt(literal);
		}

		@Override
		public Arith copy() {
			return this;
		}

		public OpInt(int literal, int line) {
			this.literal = literal;
			this.line = line;
		}

		@Override
		public Arith substitute(String name, final Arith op) {
			return this;
		}

		@Override
		public void serialize(StringBuilder sb) {
			sb.append(literal);
		}

		@Override
		public int precedence() {
			return 0;
		}

		@Override
		public String opString() {
			return String.valueOf(literal);
		}

		@Override
		public void validateVariables(HashSet<String> vars, HashSet<String> ghosts, boolean allowUseOfGhosts) {

		}
	}

	static class OpVar implements Arith {
		final String var;
		int line;

		@Override
		public AEArith toAltErgo() {
			return new AEVar(var);
		}

		@Override
		public C toC() {
			return new CVar(var);
		}

		@Override
		public Arith copy() {
			return this;
		}

		public OpVar(String var, int line) {
			this.var = var;
			this.line = line;
		}

		@Override
		public Arith substitute(String name, final Arith op) {
			return var.equals(name) ? op : this;
		}

		@Override
		public void serialize(StringBuilder sb) {
			sb.append(var);
		}

		@Override
		public int precedence() {
			return 0;
		}

		@Override
		public String opString() {
			return var;
		}

		@Override
		public void validateVariables(HashSet<String> vars, HashSet<String> ghosts, boolean allowUseOfGhosts) {
			boolean isGhost = ghosts.contains(var);
			boolean isRuntime = vars.contains(var);
			if (isGhost) {
				if (isRuntime) {
					throw new GhostVarException("\"" + var + "\" is both ghost and runtime variable", line);
				} else {
					if (!allowUseOfGhosts)
						throw new GhostVarException("Ghost variable \"" + var + "\" is not allowed here!", line);
				}
			} else {
				if (isRuntime) {

				} else {
					throw new UndefinedVarException("Used undefiend varaible " + var, line);
				}
			}

		}
	}

	interface Statement extends ProcedureAST {

		int getLine();

		void serialize(int indent, StringBuilder sb);

		void collectVariables(HashSet<String> vars, HashSet<String> ghosts);
	}

	static class Statements implements ProcedureAST {
		ArrayList<Statement> statements = new ArrayList<>();

		public Statements(Statement s) {
			statements.add(s);
		}

		public void serialize(int indent, StringBuilder sb) {
			for (Statement stmt : statements) {
				ind(sb, indent);
				stmt.serialize(indent, sb);
				sb.append('\n');
			}
		}

		public void collectVariables(HashSet<String> vars, HashSet<String> ghosts) {
			for (Statement stmt : statements) {
				stmt.collectVariables(vars, ghosts);
			}
		}

		@Override
		public void toC(int indent, StringBuilder sb, HashSet<String> ghosts) {
			for (Statement stmt : statements) {
				ind(sb, indent);
				stmt.toC(indent, sb, ghosts);
				sb.append('\n');
			}
		}

		static class PreconditionAndStatement {
			Op precondition;
			Statement prevStmt;

		}

		public void hoareGoals(LinkedList<GoalOrHole> goals, int line, Op initialAssumption, Op endCondition) {
			PreconditionAndStatement context = new PreconditionAndStatement();
			inferGoal(goals, context, line, initialAssumption);
			for (Statement stmt : statements) {
				if (stmt instanceof StatementClause) {
					inferGoal(goals, context, ((StatementClause) stmt).line, ((StatementClause) stmt).equivalence);
				} else if (stmt instanceof Assignment || stmt instanceof While || stmt instanceof If
						|| stmt instanceof Skip) {
					inferGoal(goals, context, stmt);
				}
			}
			inferGoal(goals, context, line, endCondition);
		}

		private void inferGoal(LinkedList<GoalOrHole> goals, PreconditionAndStatement context, int line,
				Op postcondition) {
			if (context.prevStmt == null) {
				goals.add(new Hole(line, HoleCause.SUPERFLUOUS_ANNOTATION));
			} else {
				if (context.prevStmt instanceof Assignment) {
					if (context.precondition != null) {
						goals.add(new GoalAssign(context.precondition, (Assignment) context.prevStmt, postcondition));
					}
				} else if (context.prevStmt instanceof Skip) {
					if (context.precondition != null) {
						goals.add(new GoalSkip(context.precondition, context.prevStmt.getLine(), postcondition));
					}
				} else if (context.prevStmt instanceof If) {
					If _if = (If) context.prevStmt;
					if (context.precondition != null) {
						_if.whenTrue.hoareGoals(goals, _if.line, new OpAnd(_if.predicate, context.precondition),
								postcondition);
						_if.whenFalse.hoareGoals(goals, _if.line,
								new OpAnd(new OpNot(_if.predicate), context.precondition), postcondition);
					} else {
						_if.whenTrue.hoareGoals(goals, _if.line, _if.predicate, postcondition);
						_if.whenFalse.hoareGoals(goals, _if.line, new OpNot(_if.predicate), postcondition);
					}
				} else if (context.prevStmt instanceof While) {
					While _while = (While) context.prevStmt;
					if (context.precondition != null) {
						goals.add(new GoalSkip(context.precondition, _while.line, _while.invariant));
					}
					_while.nested.hoareGoals(goals, line, new OpAnd(_while.invariant, _while.predicate),
							_while.invariant);
					postcondition = new OpAnd(_while.invariant, new OpNot(_while.predicate));
				}
				context.prevStmt = null;
			}
			context.precondition = postcondition;
		}

		private void inferGoal(LinkedList<GoalOrHole> goals, PreconditionAndStatement context, Statement next) {

			if (context.prevStmt != null) {
				context.precondition = null;
				goals.add(new Hole(next.getLine(), HoleCause.MISSING_ANNOTATION));
			}
			context.prevStmt = next;
		}
	}

	static class Echo implements Statement {

		int line;

		public Echo(int line) {
			this.line = line;
		}

		String prefix;
		Arith val;

		@Override
		public void collectVariables(HashSet<String> vars, HashSet<String> ghosts) {
			val.validateVariables(vars, ghosts, false);
		}

		@Override
		public void toC(int indent, StringBuilder sb, HashSet<String> ghosts) {
			sb.append("printf(\"%s%lld\", ").append(prefix).append(", ");
			val.toC().serialize(sb);
			sb.append(");");
		}

		@Override
		public void serialize(int indent, StringBuilder sb) {
			sb.append("echo ").append(prefix).append(" ");
			val.serialize(sb);
		}

		@Override
		public int getLine() {
			return line;
		}

	}

	static class Assignment implements Statement {
		String name;
		Arith value;

		public Assignment(String name, Arith value, int line) {
			this.name = name;
			this.value = value;
			this.line = line;
		}

		@Override
		public void serialize(int indent, StringBuilder sb) {
			sb.append(name).append(" := ");
			value.serialize(sb);
		}

		@Override
		public int getLine() {
			return line;
		}

		int line;

		@Override
		public void collectVariables(HashSet<String> vars, HashSet<String> ghosts) {
			boolean isGhost = ghosts.contains(name);
			value.validateVariables(vars, ghosts, isGhost);
			if (!isGhost)
				vars.add(name);
		}

		@Override
		public void toC(int indent, StringBuilder sb, HashSet<String> ghosts) {
			if (ghosts.contains(name))
				return;
			sb.append(name).append(" = ");
			value.serialize(sb);
			sb.append(";");
		}
	}

	static class If implements Statement {
		Op predicate;
		Statements whenTrue, whenFalse;

		public If(Op predicate, Statements whenTrue, Statements whenFalse, int line) {
			this.predicate = predicate;
			this.whenTrue = whenTrue;
			this.whenFalse = whenFalse;
			this.line = line;
		}

		@Override
		public void serialize(int indent, StringBuilder sb) {
			sb.append("if ");
			predicate.serialize(sb);
			sb.append(" then\n");
			whenTrue.serialize(indent + 1, sb);
			ind(sb, indent);
			sb.append("else\n");
			whenFalse.serialize(indent + 1, sb);
			ind(sb, indent);
			sb.append("fi");
		}

		@Override
		public int getLine() {
			return line;
		}

		int line;

		@Override
		public void collectVariables(HashSet<String> vars, HashSet<String> ghosts) {
			predicate.validateVariables(vars, ghosts, false);
			whenTrue.collectVariables(vars, ghosts);
			whenFalse.collectVariables(vars, ghosts);
		}

		@Override
		public void toC(int indent, StringBuilder sb, HashSet<String> ghosts) {
			sb.append("if(");
			predicate.toC().serialize(sb);
			sb.append("){\n");
			whenTrue.toC(indent + 1, sb, ghosts);
			ind(sb, indent);
			sb.append("}else{\n");
			whenFalse.toC(indent + 1, sb, ghosts);
			ind(sb, indent);
			sb.append("}");
		}

	}

	static class While implements Statement {
		final Op predicate;
		final Arith variant;
		final Statements nested;
		final Op invariant;

		public While(Op predicate, Statements nested, Op invariant, Arith variant, int line) {
			this.predicate = predicate;
			this.nested = nested;
			this.invariant = invariant;
			this.variant = variant;
			this.line = line;
		}

		@Override
		public void serialize(int indent, StringBuilder sb) {
			sb.append("while ");
			predicate.serialize(sb);
			sb.append(" invariant ");
			invariant.serialize(sb);
			sb.append(" variant ");
			variant.serialize(sb);
			sb.append(" do\n");
			nested.serialize(indent + 1, sb);
			ind(sb, indent);
			sb.append("done");
		}

		@Override
		public int getLine() {
			return line;
		}

		int line;

		@Override
		public void collectVariables(HashSet<String> vars, HashSet<String> ghosts) {
			predicate.validateVariables(vars, ghosts, false);
			variant.validateVariables(vars, ghosts, true);
			nested.collectVariables(vars, ghosts);
		}

		@Override
		public void toC(int indent, StringBuilder sb, HashSet<String> ghosts) {
			sb.append("while(");
			predicate.toC().serialize(sb);
			sb.append("){\n");
			nested.toC(indent + 1, sb, ghosts);
			ind(sb, indent);
			sb.append("}\n");
		}

	}

	static class Skip implements Statement {
		@Override
		public void serialize(int indent, StringBuilder sb) {
			sb.append("skip");
		}

		int line;

		@Override
		public int getLine() {
			return line;
		}

		public Skip(int line) {
			this.line = line;
		}

		@Override
		public void collectVariables(HashSet<String> vars, HashSet<String> ghosts) {

		}

		@Override
		public void toC(int indent, StringBuilder sb, HashSet<String> ghosts) {
		}
	}

	static class GhostVarException extends RuntimeException {
		/**
		 * 
		 */
		private static final long serialVersionUID = 1L;

		final int line;

		public GhostVarException(String message, int line) {
			super(message + " at line " + line);
			this.line = line;
		}

	}

	static class UndefinedVarException extends RuntimeException {
		/**
		 * 
		 */
		private static final long serialVersionUID = 1L;

		final int line;

		public UndefinedVarException(String message, int line) {
			super(message + " at line " + line);
			this.line = line;
		}

	}

	static class StatementClause implements Statement {
		Op equivalence;

		public StatementClause(Op equivalence, int line) {
			this.equivalence = equivalence;
			this.line = line;
		}

		@Override
		public void serialize(int indent, StringBuilder sb) {
			sb.append('{');
			equivalence.serialize(sb);
			sb.append('}');
		}

		int line;

		@Override
		public int getLine() {
			return line;
		}

		@Override
		public void toC(int indent, StringBuilder sb, HashSet<String> ghosts) {

		}

		@Override
		public void collectVariables(HashSet<String> vars, HashSet<String> ghosts) {
			equivalence.validateVariables(vars, ghosts, false);
		}
	}

	static class Ids implements AST {
		HashSet<String> ids = new HashSet<>();

		public void serialize(StringBuilder sb) {
			throw new UnsupportedOperationException("This node of AST is only a temporary holder for HashMap");
		}

	}

	private static class GrammarVisitor extends GrammarBaseVisitor<AST> {

		@Override
		public AST visitArithmVar(ArithmVarContext ctx) {
			return new OpVar(ctx.ID().getText(), ctx.start.getLine());
		}

		@Override
		public AST visitArithmLiteral(ArithmLiteralContext ctx) {
			return new OpInt(Integer.parseInt(ctx.INT().getText()), ctx.start.getLine());
		}

		@Override
		public AST visitArithmNested(ArithmNestedContext ctx) {
			Arith expr = (Arith) visit(ctx.arithemtic_expr());
			return expr;
		}

		@Override
		public AST visitArithmNeg(ArithmNegContext ctx) {
			Arith expr = (Arith) visit(ctx.arithemtic_atomic_expr());
			return new OpNeg(expr);
		}

		@Override
		public AST visitArithmNoNeg(ArithmNoNegContext ctx) {
			return visit(ctx.arithemtic_atomic_expr());
		}

		@Override
		public AST visitMultProduct(MultProductContext ctx) {
			final Arith rhs = (Arith) visit(ctx.arithemtic_term());
			final Arith lhs = (Arith) visit(ctx.arithemtic_expr_mult());
			return new OpMul(lhs, rhs);
		}

		@Override
		public AST visitMultInverse(MultInverseContext ctx) {
			final Arith rhs = (Arith) visit(ctx.arithemtic_term());
			final Arith lhs = (Arith) visit(ctx.arithemtic_expr_mult());
			return new OpDiv(lhs, rhs);
		}

		@Override
		public AST visitMultLast(MultLastContext ctx) {
			final Arith op = (Arith) visit(ctx.arithemtic_term());
			return op;
		}

		@Override
		public AST visitAirthmMinus(AirthmMinusContext ctx) {
			final Arith lhs = (Arith) visit(ctx.arithemtic_expr());
			final Arith rhs = (Arith) visit(ctx.arithemtic_expr_mult());
			return new OpSub(lhs, rhs);
		}

		@Override
		public AST visitAirthmPlus(AirthmPlusContext ctx) {
			final Arith lhs = (Arith) visit(ctx.arithemtic_expr());
			final Arith rhs = (Arith) visit(ctx.arithemtic_expr_mult());
			return new OpPlus(lhs, rhs);
		}

		@Override
		public AST visitAirthmLast(AirthmLastContext ctx) {
			return visit(ctx.arithemtic_expr_mult());
		}

		@Override
		public AST visitIneqEq(IneqEqContext ctx) {
			final Arith lhs = (Arith) visit(ctx.arithemtic_expr(0));
			final Arith rhs = (Arith) visit(ctx.arithemtic_expr(1));
			return new OpEq(lhs, rhs);
		}

		@Override
		public AST visitIneqGe(IneqGeContext ctx) {
			final Arith lhs = (Arith) visit(ctx.arithemtic_expr(0));
			final Arith rhs = (Arith) visit(ctx.arithemtic_expr(1));
			return new OpLe(rhs, lhs);
		}

		@Override
		public AST visitIneqGt(IneqGtContext ctx) {
			final Arith lhs = (Arith) visit(ctx.arithemtic_expr(0));
			final Arith rhs = (Arith) visit(ctx.arithemtic_expr(1));
			return new OpLt(rhs, lhs);
		}

		@Override
		public AST visitIneqLe(IneqLeContext ctx) {
			final Arith lhs = (Arith) visit(ctx.arithemtic_expr(0));
			final Arith rhs = (Arith) visit(ctx.arithemtic_expr(1));
			return new OpLe(lhs, rhs);
		}

		@Override
		public AST visitIneqLt(IneqLtContext ctx) {
			final Arith lhs = (Arith) visit(ctx.arithemtic_expr(0));
			final Arith rhs = (Arith) visit(ctx.arithemtic_expr(1));
			return new OpLt(lhs, rhs);
		}

		@Override
		public AST visitIneqNeq(IneqNeqContext ctx) {
			final Arith lhs = (Arith) visit(ctx.arithemtic_expr(0));
			final Arith rhs = (Arith) visit(ctx.arithemtic_expr(1));
			return new OpNot(new OpEq(lhs, rhs));
		}

		@Override
		public AST visitAtomLogic(AtomLogicContext ctx) {
			return visit(ctx.equivalence());
		}

		@Override
		public AST visitAtomArithm(AtomArithmContext ctx) {
			return visit(ctx.inequality());
		}

		@Override
		public AST visitAtomFalse(AtomFalseContext ctx) {
			return FALSE;
		}

		@Override
		public AST visitAtomTrue(AtomTrueContext ctx) {
			return TRUE;
		}

		@Override
		public AST visitNegationTrue(NegationTrueContext ctx) {
			return visit(ctx.atom());
		}

		@Override
		public AST visitNegationFalse(NegationFalseContext ctx) {
			return new OpNot((Op) visit(ctx.atom()));
		}

		@Override
		public AST visitConjunctionLast(ConjunctionLastContext ctx) {
			return visit(ctx.negation());
		}

		@Override
		public AST visitConjunctionMore(ConjunctionMoreContext ctx) {
			final Op rhs = (Op) visit(ctx.conjunction());
			final Op lhs = (Op) visit(ctx.negation());
			return new OpAnd(lhs, rhs);
		}

		@Override
		public AST visitDisjunctionLast(DisjunctionLastContext ctx) {
			return visit(ctx.conjunction());
		}

		@Override
		public AST visitDisjunctionMore(DisjunctionMoreContext ctx) {
			final Op lhs = (Op) visit(ctx.conjunction());
			final Op rhs = (Op) visit(ctx.disjunction());
			return new OpOr(lhs, rhs);
		}

		@Override
		public AST visitImplicationLast(ImplicationLastContext ctx) {
			return visit(ctx.disjunction());
		}

		@Override
		public AST visitImplicationMore(ImplicationMoreContext ctx) {
			final Op lhs = (Op) visit(ctx.disjunction());
			final Op rhs = (Op) visit(ctx.implication());
			return new OpImpl(lhs, rhs);
		}

		@Override
		public AST visitEquivalenceLast(EquivalenceLastContext ctx) {
			return visit(ctx.implication());
		}

		@Override
		public AST visitEquivalenceMore(EquivalenceMoreContext ctx) {
			final Op lhs = (Op) visit(ctx.implication(0));
			final Op rhs = (Op) visit(ctx.implication(1));
			return new OpEquiv(lhs, rhs);
		}

		@Override
		public AST visitStatementWhile(StatementWhileContext ctx) {
			Op test = (Op) visit(ctx.equivalence(0));
			Op invariant = (Op) visit(ctx.equivalence(1));
			Statements loop = (Statements) visit(ctx.statements());
			Arith variant = (Arith) visit(ctx.arithemtic_expr());
			While _while = new While(test, loop, invariant, variant, ctx.start.getLine());
			return _while;
		}

		@Override
		public AST visitStatementsLast(StatementsLastContext ctx) {
			Statement head = (Statement) visit(ctx.statement());
			Statements statements = new Statements(head);
			return statements;
		}

		@Override
		public AST visitStatementIf(StatementIfContext ctx) {
			Op test = (Op) visit(ctx.equivalence());
			Statements ifTrue = (Statements) visit(ctx.statements(0));
			Statements ifFalse = (Statements) visit(ctx.statements(1));
			If _if = new If(test, ifTrue, ifFalse, ctx.start.getLine());
			return _if;
		}

		@Override
		public AST visitStatementAssign(StatementAssignContext ctx) {
			String id = ctx.ID().getText();
			Arith expr = (Arith) visit(ctx.arithemtic_expr());
			Assignment ass = new Assignment(id, expr, ctx.start.getLine());
			return ass;
		}

		@Override
		public AST visitStatementClause(StatementClauseContext ctx) {
			Op eq = (Op) visit(ctx.equivalence());
			StatementClause clause = new StatementClause(eq, ctx.start.getLine());
			return clause;
		}

		@Override
		public AST visitStatementEcho(StatementEchoContext ctx) {
			String prefix = ctx.StringLiteral().getText();
			Arith val = (Arith) visit(ctx.arithemtic_expr());
			Echo echo = new Echo(ctx.start.getLine());
			echo.prefix = prefix;
			echo.val = val;
			return echo;
		}

		@Override
		public AST visitStatementSkip(StatementSkipContext ctx) {
			return new Skip(ctx.start.getLine());
		}

		@Override
		public AST visitStatementsMore(StatementsMoreContext ctx) {
			Statement head = (Statement) visit(ctx.statement());
			Statements tail = (Statements) visit(ctx.statements());
			tail.statements.add(0, head);
			return tail;
		}

		@Override
		public AST visitProcedure(ProcedureContext ctx) {
			Procedure procedure = new Procedure(ctx.start.getLine());
			procedure.name = ctx.ID().getText();
			procedure.requires = (Op) visit(ctx.equivalence(0));
			procedure.ensures = (Op) visit(ctx.equivalence(1));
			procedure.steps = (Statements) visit(ctx.statements());
			Ids vars = (Ids) visit(ctx.ids(0));
			Ids ghosts = (Ids) visit(ctx.ids(1));
			procedure.variables = vars.ids;
			procedure.ghosts = ghosts.ids;
			return procedure;
		}

		@Override
		public AST visitProceduresMore(ProceduresMoreContext ctx) {
			Procedures procedures = (Procedures) visit(ctx.procedures());
			Procedure procedure = (Procedure) visit(ctx.procedure());
			procedures.procedures.addFirst(procedure);
			return procedures;
		}

		@Override
		public AST visitIDMore(IDMoreContext ctx) {
			Ids ids = (Ids) visit(ctx.ids());
			ids.ids.add(ctx.ID().getText());
			return ids;
		}

		@Override
		public AST visitIDLast(IDLastContext ctx) {
			return new Ids();
		}

		@Override
		public AST visitProceduresLast(ProceduresLastContext ctx) {
			return new Procedures();
		}

		@Override
		public AST visitStart(StartContext ctx) {
			return visit(ctx.procedures());
		}
	}

	private static final String source = "procedure main\n" + 
			"    requires true   \n" + 
			"    ensures z >= x /\\ z >= y    \n" + 
			"    vars x y z  \n" + 
			"    ghost          \n" + 
			"    steps      \n" + 
			"    if x < y then\n" + 
			"        z := y\n" + 
			"    else\n" + 
			"        z := x\n" + 
			"    fi\n" +
			"    echo \"X=\" x\n"+
			"    echo \"\\nY=\" y\n"+
			"    echo \"\\nMax=\" z\n"+
			"end";

	public static void main(String[] args) throws IOException, InterruptedException {

		CharStream inputStream = CharStreams.fromString(source);
		GrammarLexer lexer = new GrammarLexer(inputStream);
		GrammarParser parser = new GrammarParser(new CommonTokenStream(lexer));
		GrammarVisitor visitor = new GrammarVisitor();
		Procedures out = (Procedures) visitor.visit(parser.start());
		System.out.println("======= HoareC source =======");
		System.out.println(out.str());
		System.out.println("======= C source =======");
		final String c = out.toC();
		System.out.println(c);
		System.out.println("======= Alt-Ergo goals =======");
		LinkedList<GoalOrHole> goals = out.hoareGoals();
		for (GoalOrHole goal : goals) {
			StringBuilder sb = new StringBuilder();
			goal.toAltErgo(sb);
			System.out.println(sb.toString());
		}
		System.out.println("======= GCC start =======");
		File executable = new File("main");
		executable.delete();
		System.out.println("producing " + executable.getAbsolutePath());
		ProcessBuilder gcc = new ProcessBuilder("gcc", "-x", "c", "-o", "main", "-");
		gcc.redirectError(Redirect.INHERIT);
		Process gccProcess = gcc.start();
		gccProcess.getOutputStream().write(c.getBytes());
		gccProcess.getOutputStream().flush();
		gccProcess.getOutputStream().close();
		gccProcess.waitFor();
		System.out.println("======= GCC finished =======");
		System.out.println("======= Running =======");
		ProcessBuilder main = new ProcessBuilder(executable.getAbsolutePath());
		main.inheritIO();
		main.start().waitFor();
		System.out.println("\n======= Finished =======");
	}
}
